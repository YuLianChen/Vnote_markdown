### 一、 核心框架层（App 容器与生命周期管理）

#### 1. 解耦的应用/页面描述符 (Descriptor)

为了实现插件化，我们需要两层描述结构：

- **App 描述符 (App Manifest)：** 定义应用的身份与资源。
    
    - **App ID & Name：** 唯一的十六进制 ID 和字符串名称。
        
    - **资源配额：** 规定该 App 最大可申请的 RT-Thread 堆栈大小、优先级。
        
    - **入口地址：** 启动 App 的初始函数指针。
        
- **页面描述符 (Page Descriptor)：** App 内部可以包含多个页面，每个页面由 Navigator 管理。
    
    - **Page ID：** 内部跳转索引。
        
    - **父对象指针：** 自动关联 `lv_obj_t *root`，销毁页面时一键释放。
        

#### 2. 严格的生命周期管理 (Lifecycle)

我们将生命周期分为**应用级**和**页面级**，以解决资源回收和视觉切换的冲突：

- **App 级生命周期（由系统 Manager 控制）：**
    
    - **`App_Init`：** 申请 RTT 信号量、初始化后端通信协议、加载配置文件。
        
    - **`App_Deinit`：** 彻底杀死 App 线程、释放所有动态内存、注销所有消息订阅。
        
- **Page 级生命周期（由 Navigator 控制）：**
    
    - **`onLoad`：** 静态 UI 资源创建（`lv_obj_create`），此时页面在内存中但未显示。
        
    - **`onStart` / `onEnter`：** 页面切入前台。此时绑定按键组（Group）、开启页面动画。
        
    - **`onPause`：** 页面被新页面覆盖。停止本页动画，但保留 UI 对象（实现快速返回）。
        
    - **`onResume`：** 从堆栈返回该页。重新激活按键绑定，刷新最新传感器数据。
        
    - **`onDestroy` / `onExit`：** 页面彻底从栈中移除。执行 `lv_obj_del`，释放 UI 专用的临时 Buffer。
        

#### 3. 增强型页面管理器 (Navigator)

管理器不再只是简单的“跳转”，而是充当“管家”：

- **自动 Group 管理（物理键适配）：**
    
    - 框架维护一个全局 `lv_group_t`。
        
    - 当 `onEnter` 触发时，Navigator 自动清除旧 Group 内的对象，并将当前页面的交互组件（按钮、滑块）加入 Group，无需开发者手动调用 `lv_group_add_obj`。
        
- **页面栈与单例模式：**
    
    - 支持 `Push`（入栈）和 `Pop`（回退）。
        
    - 提供“单例页面”配置：例如“设置”页面，无论从哪个路径进入，栈内只允许存在一个实例。
    
- **页面动画：**
	- 页面切换动画效果的实现

#### 4. 全局覆盖层 (Overlay Manager)

独立于 App 页面栈之外的特殊层：

- **Z-Index 顶层置顶：** 利用 LVGL 的 `lv_layer_sys()` 或 `lv_layer_top()`。
    
- **状态栏 (StatusBar)：** 挂载电量、RSSI、时间组件，App 切换时该层不刷新、不销毁。
    
- **吐司通知 (Toast/Dialog)：** 提供全局 API（如 `Show_Toast("Battery Low")`），允许后端线程直接触发弹出，不干扰当前 App 的业务逻辑。
        

---

### 二、 数据交互层（前后端通信）

3. **线程安全的双向数据总线**
    
    - **异步下行（Backend → UI）：** 建议引入“消息订阅”机制。后端 RTT 线程更新数据后，发布消息，UI 框架在 `lv_timer` 中统一处理订阅逻辑，避免直接在非 UI 线程调用 LVGL 函数。
        
    - **同步上行（UI → Backend）：** 引入“命令队列”。UI 点击按钮后，发送一个 Cmd 到后端队列，而不是直接在回调里写死逻辑代码。
        
4. **状态快照与参数恢复**
    
    - **系统信息预载：** 框架提供 `System_GetSnapshot()` 接口，App 启动瞬间即可获得所有传感器、网络、系统状态的当前值，消除 UI 刷出来后“闪烁更新”或“等待数据”的白屏感。
        

---

### 三、 资源与表现层（解耦与动态加载）

5. **样式表（CSS-like Theming）**
    
    - **属性继承机制：** 仿照 CSS 定义全局配色方案（Palette）和尺寸定义（Metrics）。App 内部只引用 `STYLE_PRIMARY_BTN` 这种宏，修改全局表即可实现一键换肤。
        
6. **虚拟资源管理器（Virtual Assets Loader）**
    
    - **外部 Flash 懒加载：** 图片和字库不直接编译进 Bin。建立索引表，根据 ID 从 Flash 动态读取二进制数据。
        
    - **LRU 缓存策略：** 针对 Flash 读取速度慢的问题，在 RAM 中开辟一小块“热点资源缓存”，存放最近使用的图标。
        

---

### 四、 内存与性能管理（精细化控制）

7. **动态堆内存监控**
    
    - **App 独立配额：** 限制单个 App 申请的堆空间，防止某个 App 内存泄漏导致整个系统 OOM（内存溢出）。
        
    - **深度清理：** 在 App 退出时，不仅要 `lv_obj_del`，还要确保其关联的后端线程、信号量、动态分配的 Buffer 被 RTT 彻底回收。
        
8. **刷新率与低功耗策略（新增建议）**
    
    - **动态 FPS：** 静态页面降低到 5-10 FPS，动画或滑动时恢复到 30-60 FPS，结合 RTT 的 PM 组件，在无操作时降低背光或进入轻度睡眠。
        

### 五、 稳定性与开发保障

9. **异常沙箱与自动回退**
    
    - **Watchdog 联动：** 如果 UI 线程卡死超过设定时间，硬件看门狗复位前，框架应能记录错误日志。
        
    - **安全模式：** 若某个 App 连续崩溃 3 次，将其在主界面“置灰”或禁用，引导用户进入“恢复模式”。
        
10. **自动化测试与模拟器（DevOps）**
    
    - **指令回放系统：** 能够录制一段按键/触摸序列，并在真机上复现，用于压力测试。
        
    - **断言系统：** 测试脚本能读取特定对象的属性（如：`assert(label_speed == "120km/h")`），验证业务逻辑正确性。
    
